# Отчёт по практической работе №3
## Реализация архитектурного паттерна MVVM

### **Цель работы**

Целью данной практической работы являлось углубленное изучение и внедрение архитектурного паттерна **MVVM (Model-View-ViewModel)** в существующие проекты. Основные задачи включали:

- **Рефакторинг слоя `Presentation`:** Перенос всей бизнес-логики и логики управления состоянием из `Activity` в отдельный класс `ViewModel`.
- **Обеспечение устойчивости к изменениям конфигурации:** Использование `ViewModel` для сохранения состояния UI при пересоздании `Activity` (например, при повороте экрана).
- **Реализация "реактивной" архитектуры:** Внедрение `LiveData` для организации однонаправленного потока данных от `ViewModel` к `View` (Activity).
- **Решение проблемы создания `ViewModel` с зависимостями:** Создание и применение `ViewModelFactory` для корректной инициализации `ViewModel`.
- **Изучение и применение `MediatorLiveData`:** В рамках контрольного задания требовалось использовать `MediatorLiveData` для управления несколькими источниками данных.

### **Модификация слоя App (проект `MovieProject`)**

Основное задание по внедрению MVVM выполнялось на учебном проекте `MovieProject`, который был доработан и преобразован в многомодульный в рамках предыдущей работы.

#### **Создание и внедрение ViewModel**

Первым шагом был осуществлен перенос всей логики из `MainActivity` в новый класс `MainViewModel` для разделения ответственности.

1.  В `app`-модуль была добавлена зависимость `androidx.lifecycle:lifecycle-viewmodel`.
2.  В пакете `presentation` был создан класс `MainViewModel`, унаследованный от `androidx.lifecycle.ViewModel`.
3.  Все поля, связанные с бизнес-логикой (`GetFavoriteFilmUseCase`, `SaveFilmToFavoriteUseCase`), а также логика вызова их методов, были перемещены из `MainActivity` в `MainViewModel`. `MainActivity` была "очищена" и теперь отвечает только за отображение UI.

<img width="1000" height="500" alt="image" src="https://github.com/user-attachments/assets/ae12cd99-68d0-42a1-896e-9acf945c6c4d" />


#### **Создание ViewModelFactory**

Для решения проблемы создания `MainViewModel`, который имеет сложные зависимости (требует `Context` для инициализации `data`-слоя), был реализован паттерн "Фабрика", как это описано в методическом пособии.

1.  Был создан класс `ViewModelFactory`, реализующий интерфейс `ViewModelProvider.Factory`.
2.  Вся логика по созданию экземпляров `MovieStorage`, `MovieRepositoryImpl` была перенесена из `MainActivity` в метод `create()` фабрики.
3.  В `MainActivity` весь блок инициализации был заменен одной строкой, получающей готовый `ViewModel` от `ViewModelProvider` с использованием нашей фабрики.

<img width="1000" height="500" alt="image" src="https://github.com/user-attachments/assets/fe6d48bd-e98e-480c-aca8-b5670c96aaed" />


#### **Внедрение LiveData**

Для организации связи между `MainViewModel` и `MainActivity` был внедрен компонент `LiveData`, что позволило реализовать "реактивный" подход к обновлению UI.

1.  В `MainViewModel` обычные поля для хранения данных были заменены на `MutableLiveData` и `LiveData`.
2.  Методы `ViewModel` (`setText`, `getText`) были модифицированы: теперь они не возвращают значения, а обновляют состояние `LiveData` через метод `.setValue()`.
3.  В `MainActivity` была реализована подписка на `LiveData` с помощью метода `.observe()`. Внутри `Observer`-а происходит обновление `TextView` при поступлении новых данных от `ViewModel`. Это позволило сохранить состояние экрана при повороте устройства.

<img width="400" height="300" alt="1" src="https://github.com/user-attachments/assets/bc113602-7bf8-4eb2-be2f-1f3c1091fb1a"/> <img width="400" height="300" alt="2" src="https://github.com/user-attachments/assets/fcb13022-d83c-4c88-a2bd-c5fb205bcf7b" />


### **Контрольное задание (проект `PocketDictionary`)**

Контрольное задание по применению MVVM и `MediatorLiveData` выполнялось на основном проекте `PocketDictionary`.

1.  **Реализован `MainViewModel`** для `PocketDictionary`, в который была перенесена логика работы с `GetWordDefinitionUseCase` и `SaveFavoriteWordUseCase`.

<img width="1000" height="500" alt="image" src="https://github.com/user-attachments/assets/28b83930-c79d-4bb4-af30-0246619f785b" />

2.  **Создана `MainViewModelFactory`**, которая инкапсулирует всю сложную логику создания зависимостей (`Room`, `NetworkApi`, `SharedPreferences`, `WordRepositoryImpl`).

<img width="1000" height="500" alt="image" src="https://github.com/user-attachments/assets/14f10656-f4b5-409f-b4c8-ca4667a76a58" />

3.  **Реализована `LiveData`** для передачи `WordDefinition` и `Toast`-сообщений от `ViewModel` к `MainActivity`.
4.  **Применен `MediatorLiveData`:**
    *   Для управления потоком данных в `MainViewModel` был использован `MediatorLiveData`.
    *   Были созданы два `LiveData`-триггера: `searchTrigger` (для нового поиска) и `refreshTrigger` (для обновления).
    *   `MediatorLiveData` был подписан на оба триггера. При срабатывании любого из них, `Mediator` запускает соответствующую логику (вызов `UseCase`), получает результат из "замоканных" источников (БД и сети) и обновляет свое собственное состояние, которое наблюдает `MainActivity`.

<img width="400" height="400" alt="3" src="https://github.com/user-attachments/assets/244e6ef7-e1ef-4820-a1e2-7fa67cca5f38" /> <img width="400" height="400" alt="4" src="https://github.com/user-attachments/assets/22fc48eb-1573-4292-8fd6-1c084c9c887f" />

<img width="400" height="400" alt="5" src="https://github.com/user-attachments/assets/4cc1ce14-8c83-4ad3-aa59-afab528e88fa" /> <img width="400" height="400" alt="6" src="https://github.com/user-attachments/assets/19c502e5-e2c3-4e91-9d86-262c51b2c69f" />

<img width="500" height="700" alt="7" src="https://github.com/user-attachments/assets/f9c82bf1-bb88-4b36-b3cc-67c8cfd34ef5" />





