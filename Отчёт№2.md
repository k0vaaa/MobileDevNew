# Отчёт по практической работе №2

## Тема: Рефакторинг и расширение архитектуры мобильного приложения

### **1. Цель работы**

Целью данной практической работы являлось углубление архитектуры, созданной в предыдущем задании, и приведение ее к профессиональным стандартам разработки. Основные задачи включали:

1.  **Рефакторинг Data-слоя:** Выделение логики хранения данных в отдельную сущность (`Storage`) для повышения чистоты и гибкости репозитория.
2.  **Разделение моделей данных:** Введение отдельных моделей для каждого слоя (`Domain` и `Data`) и реализация механизма их преобразования (маппинга).
3.  **Создание многомодульного проекта:** Преобразование логических слоев (`domain`, `data`) в физически изолированные Gradle-модули для обеспечения строгой архитектуры.
4.  **Реализация нового функционала:** Добавление экрана авторизации с использованием Firebase Authentication и усложнение логики репозитория путем введения нескольких источников данных (Room, Network, SharedPreferences).

### **2. Рефакторинг архитектуры приложения "PocketDictionary"**

Для выполнения работы был взят проект "PocketDictionary", созданный в рамках контрольного задания предыдущей практической работы.

#### **2.1. Введение слоя Storage**

Для улучшения архитектуры `Data`-слоя и следования принципу единственной ответственности (Single Responsibility Principle) была введена дополнительная абстракция — `Storage`.

1.  **Создан интерфейс `WordStorage`** в пакете `data/storage`, определяющий контракт для любого локального хранилища (`save()` и `get()`).
2.  **Создан класс `SharedPrefWordStorage`**, реализующий `WordStorage` и инкапсулирующий в себе всю логику работы с `SharedPreferences`, которая ранее находилась в репозитории.
3.  **Обновлен `WordRepositoryImpl`**: из него была удалена прямая работа с `SharedPreferences`. Теперь репозиторий принимает в конструкторе зависимость от интерфейса `WordStorage` и делегирует ему задачи по сохранению и чтению данных. Таким образом, репозиторий стал выполнять роль "диспетчера" (роутера).

#### **2.2. Разделение моделей и маппинг**

Для обеспечения полной независимости `Data`-слоя от `Domain`-слоя были введены раздельные модели данных.

1.  **Создана модель `WordDataModel`** в пакете `data/storage/models`. Эта модель предназначена исключительно для использования внутри `Data`-слоя.
2.  **Обновлен `WordStorage`** и его реализация, которые теперь оперируют только `WordDataModel`.
3.  **В `WordRepositoryImpl` были реализованы приватные методы-мапперы**: `mapToStorage()` и `mapToDomain()`. Эти методы выполняют преобразование между `WordDefinition` (Domain) и `WordDataModel` (Data). Теперь репозиторий выступает в роли "переводчика" между слоями.

#### **2.3. Создание многомодульного проекта**

Для обеспечения строгой физической изоляции слоев проект был преобразован в многомодульный.

1.  **Создан модуль `:domain`** типа `Java or Kotlin Library`. Весь пакет `domain` был перемещен из `app`-модуля в новый модуль.
2.  **Создан модуль `:data`** типа `Android Library`. Пакет `data` был перемещен в этот модуль.
3.  **Настроены зависимости в Gradle:**
    *   `app`-модуль получил зависимости от `:domain` и `:data`.
    *   `data`-модуль получил зависимость от `:domain`.
    *   `domain`-модуль остался полностью независимым.

### **3. Контрольное задание**

#### **3.1. Реализация авторизации через Firebase**

Был добавлен новый функционал авторизации пользователя.

1.  **Создан экран `AuthActivity`** с соответствующим макетом, включающим поля для ввода email/пароля и кнопки "Login"/"Register".
2.  **Проект был подключен к Firebase**, и была добавлена зависимость `Firebase Authentication`.
3.  **Архитектура авторизации** была выстроена по аналогии с основным функционалом:
    *   **В `domain`-слое** были созданы интерфейс `AuthRepository` и классы `LoginUseCase`, `RegisterUseCase`.
    *   **В `data`-слое** был создан класс `AuthRepositoryImpl`, инкапсулирующий реальные вызовы `FirebaseAuth`. Для обработки асинхронных операций Firebase были использованы колбэки.
    *   **В `AuthActivity`** была выполнена "сборка" зависимостей и настроены обработчики нажатий на кнопки.

#### **3.2. Реализация трех способов обработки данных**

Логика `WordRepositoryImpl` была значительно усложнена для управления тремя различными источниками данных.

1.  **Реализована работа с базой данных Room:**
    *   В `data`-модуль были добавлены зависимости Room.
    *   Созданы все необходимые компоненты: `WordEntity`, `WordDao` и `AppDatabase`.
2.  **Создана имитация сетевого слоя:**
    *   В `data`-модуле был создан класс `NetworkApi`, имитирующий запрос в сеть и возвращающий тестовые данные.
3.  **Обновлен `WordRepositoryImpl`:**
    *   Конструктор репозитория теперь принимает все три источника данных: `WordStorage` (для SharedPreferences), `WordDao` (для Room) и `NetworkApi`.
    *   Метод `getDefinition()` реализует следующую логику кэширования: сначала он ищет данные в Room, и только если их там нет, обращается к `NetworkApi`, после чего сохраняет полученный результат в оба кэша (Room и SharedPreferences).
