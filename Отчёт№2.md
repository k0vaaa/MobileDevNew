# Отчёт по практической работе №2

## Рефакторинг и расширение архитектуры мобильного приложения

### **Цель работы**

Целью данной практической работы являлось углубление архитектуры, созданной в предыдущем задании, и приведение ее к профессиональным стандартам разработки. Основные задачи включали:

- **Рефакторинг Data-слоя:** Выделение логики хранения данных в отдельную сущность (`Storage`) для повышения чистоты и гибкости репозитория.
- **Разделение моделей данных:** Введение отдельных моделей для каждого слоя (`Domain` и `Data`) и реализация механизма их преобразования (маппинга).
- **Создание многомодульного проекта:** Преобразование логических слоев (`domain`, `data`) в физически изолированные Gradle-модули для обеспечения строгой архитектуры.
- **Реализация нового функционала:** Добавление экрана авторизации с использованием Firebase Authentication и усложнение логики репозитория путем введения нескольких источников данных (Room, Network, SharedPreferences).

### Рефакторинг архитектуры приложения "PocketDictionary"

Для выполнения работы был взят проект "PocketDictionary", созданный в рамках контрольного задания предыдущей практической работы.

#### Введение слоя Storage

Для улучшения архитектуры `Data`-слоя и следования принципу единственной ответственности (Single Responsibility Principle) была введена дополнительная абстракция — `Storage`.

1.  **Создан интерфейс `WordStorage`** в пакете `data/storage`, определяющий контракт для любого локального хранилища (`save()` и `get()`).
2.  **Создан класс `SharedPrefWordStorage`**, реализующий `WordStorage` и инкапсулирующий в себе всю логику работы с `SharedPreferences`, которая ранее находилась в репозитории.
3.  **Обновлен `WordRepositoryImpl`**: из него была удалена прямая работа с `SharedPreferences`. Теперь репозиторий принимает в конструкторе зависимость от интерфейса `WordStorage` и делегирует ему задачи по сохранению и чтению данных. Таким образом, репозиторий стал выполнять роль "диспетчера" (роутера).

<img width="579" height="630" alt="image" src="https://github.com/user-attachments/assets/a99e2d9f-8e0c-4c21-a903-04087f1c002d" />

#### Разделение моделей и маппинг

Для обеспечения полной независимости `Data`-слоя от `Domain`-слоя были введены раздельные модели данных.

1.  **Создана модель `WordDataModel`** в пакете `data/storage/models`. Эта модель предназначена исключительно для использования внутри `Data`-слоя.
2.  **Обновлен `WordStorage`** и его реализация, которые теперь оперируют только `WordDataModel`.
3.  **В `WordRepositoryImpl` были реализованы приватные методы-мапперы**: `mapToStorage()` и `mapToDomain()`. Эти методы выполняют преобразование между `WordDefinition` (Domain) и `WordDataModel` (Data). Теперь репозиторий выступает в роли "переводчика" между слоями.

#### Создание многомодульного проекта

Для обеспечения строгой физической изоляции слоев проект был преобразован в многомодульный.

1.  **Создан модуль `:domain`** типа `Java or Kotlin Library`. Весь пакет `domain` был перемещен из `app`-модуля в новый модуль.
2.  **Создан модуль `:data`** типа `Android Library`. Пакет `data` был перемещен в этот модуль.
3.  **Настроены зависимости в Gradle:**
    *   `app`-модуль получил зависимости от `:domain` и `:data`.
    *   `data`-модуль получил зависимость от `:domain`.
    *   `domain`-модуль остался полностью независимым.
  
<img width="801" height="1245" alt="image" src="https://github.com/user-attachments/assets/2f4c4853-fb27-499e-9345-b9faeb8736c2" />

### Контрольное задание

#### Реализация авторизации через Firebase

Был добавлен новый функционал авторизации пользователя.

1.  **Создан экран `AuthActivity`** с соответствующим макетом, включающим поля для ввода email/пароля и кнопки "Login"/"Register".
2.  **Проект был подключен к Firebase**, и была добавлена зависимость `Firebase Authentication`.
3.  **Архитектура авторизации** была выстроена по аналогии с основным функционалом:
    *   **В `domain`-слое** были созданы интерфейс `AuthRepository` и классы `LoginUseCase`, `RegisterUseCase`.
    *   **В `data`-слое** был создан класс `AuthRepositoryImpl`, инкапсулирующий реальные вызовы `FirebaseAuth`. Для обработки асинхронных операций Firebase были использованы колбэки.
    *   **В `AuthActivity`** была выполнена "сборка" зависимостей и настроены обработчики нажатий на кнопки.

<img width="2277" height="821" alt="image" src="https://github.com/user-attachments/assets/20978f36-efb6-4c6f-9fa2-810d70276d45" />

<img width="300" height="600" alt="image" src="https://github.com/user-attachments/assets/6c16f9e7-14e7-4fd1-b9f8-3329dacad681" /> <img width="300" height="600" alt="image" src="https://github.com/user-attachments/assets/6aeb942d-15c3-4f23-b6c9-9416d9c4f2cb" /> <img width="300" height="600" alt="image" src="https://github.com/user-attachments/assets/8ae6549c-a4bb-4523-a5e6-75468536c432" />





#### Реализация трех способов обработки данных

Логика `WordRepositoryImpl` была значительно усложнена для управления тремя различными источниками данных.

1.  **Реализована работа с базой данных Room:**
    *   В `data`-модуль были добавлены зависимости Room.
    *   Созданы все необходимые компоненты: `WordEntity`, `WordDao` и `AppDatabase`.
2.  **Создана имитация сетевого слоя:**
    *   В `data`-модуле был создан класс `NetworkApi`, имитирующий запрос в сеть и возвращающий тестовые данные.
3.  **Обновлен `WordRepositoryImpl`:**
    *   Конструктор репозитория теперь принимает все три источника данных: `WordStorage` (для SharedPreferences), `WordDao` (для Room) и `NetworkApi`.
    *   Метод `getDefinition()` реализует следующую логику кэширования: сначала он ищет данные в Room, и только если их там нет, обращается к `NetworkApi`, после чего сохраняет полученный результат в оба кэша (Room и SharedPreferences).

#### Создание прототипа приложения в Figma

В Figma был разработан прототип приложения, состоящий из четырех экранов.

<img width="1512" height="688" alt="image" src="https://github.com/user-attachments/assets/268e9359-43ac-4e87-9852-02258e8e3fa3" />

1. **Экран входа**
   * Является начальной точкой входа в приложение. Предлагает пользователю ввести учетные данные (email и пароль) и предоставляет две опции: "Войти" для аутентификации или "Регистрация" для создания новой учетной записи.
3. **Экран определений**
   * Основной рабочий экран, имеющий два режима. Изначально он предлагает поле для ввода и ключевую кнопку "Поиск". После выполнения запроса интерфейс обновляется, демонстрируя результат: искомое слово, карточку с его толкованием, а также элементы управления для добавления в избранное и сброса поиска.
5. **Экран коллекции**
   * Демонстрирует прокручиваемый по вертикали перечень всех слов, которые пользователь ранее сохранил. Каждый пункт в списке включает само слово, его краткую аннотацию и элемент "Х" для удаления из коллекции.
7. **Перемещение по приложению**
   * Доступ к экрану определений открывается после успешного входа в систему. Переход к экрану коллекции выполняется через отдельный элемент интерфейса. Возможность выйти из профиля реализована через иконку в верхней части экрана определений.

