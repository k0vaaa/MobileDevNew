# Отчёт по практической работе №5
## Сетевое взаимодействие в Android. Retrofit и Picasso

### **Цель работы**

Целью данной практической работы являлось изучение и практическое освоение инструментов для организации сетевого взаимодействия в Android-приложении. Основные задачи включали:

-   **Изучение `Retrofit`:** Освоение принципов работы с библиотекой Retrofit для выполнения HTTP-запросов к REST API, включая создание API-интерфейсов, POJO/DTO моделей для парсинга JSON и выполнение асинхронных запросов.
-   **Изучение `Picasso`:** Применение библиотеки Picasso для асинхронной загрузки, кэширования и отображения изображений из сети.
-   **Обработка ошибок:** Реализация механизмов обработки сетевых ошибок и ошибок загрузки изображений.
-   **Выполнение контрольного задания:** Интеграция `Retrofit` и `Picasso` в основной проект "PocketDictionary" для замены "заглушек" на реальное взаимодействие с внешними сервисами.

### **Практическая работа (`RetrofitApp`)**

Для освоения базовых концепций сетевого взаимодействия был создан отдельный учебный модуль `RetrofitApp`.

#### **Реализация `Retrofit`**

Было реализовано приложение, которое получает список дел (To-Do list) с публичного API `jsonplaceholder.typicode.com`.

1.  **Настроены зависимости:** В `build.gradle.kts` были добавлены библиотеки `Retrofit` и `converter-gson`.
2.  **Создана модель `Todo.java`**, описывающая структуру одного дела.
3.  **Создан интерфейс `ApiService.java`** с описанием GET-запроса (`@GET("todos")`) для получения списка дел и PUT-запроса (`@PUT("todos/{id}")`) для обновления статуса дела.
4.  **В `MainActivity`** был настроен клиент `Retrofit` и выполнен асинхронный запрос `call.enqueue()`. Были реализованы колбэки `onResponse` и `onFailure` для обработки успешного ответа и возможных ошибок.

Ниже представлен фрагмент `MainActivity` с реализацией запроса.
```java
    apiService = retrofit.create(ApiService.class);
    Call<List<Todo>> call = apiService.getTodos();
    call.enqueue(new Callback<List<Todo>>() {
        @Override
        public void onResponse(@NonNull Call<List<Todo>> call, @NonNull Response<List<Todo>> response) {
            if (response.isSuccessful() && response.body() != null) {
                List<Todo> todos = response.body();
                todoAdapter = new TodoAdapter(MainActivity.this, todos, apiService);
                recyclerView.setAdapter(todoAdapter);
            } else {
                Log.e(TAG, "onResponse: Error code " + response.code());
            }
        }
        @Override
        public void onFailure(@NonNull Call<List<Todo>> call, @NonNull Throwable t) {
            Log.e(TAG, "onFailure: " + t.getMessage());
        }
    });
```
#### **Отображение данных и изображений**
Полученные данные были отображены в `RecyclerView`.
1. Создан `TodoAdapter` с `TodoViewHolder` для отображения списка.
2. Реализовано обновление статуса: В `onBindViewHolder` на `CheckBox` был установлен слушатель, который при изменении состояния отправляет PUT-запрос на сервер для обновления задачи.
3. Интегрирован Picasso: В макет элемента `item_todo.xml` был добавлен `ImageView`.

<img width="400" height="350" alt="image" src="https://github.com/user-attachments/assets/a073b6dd-2b48-4587-b450-2095be2b729f" />

5.  В `onBindViewHolder` с помощью Picasso в этот `ImageView` загружается статичное изображение-заглушка для демонстрации работы библиотеки.

Ниже представлен фрагмент TodoAdapter с реализацией Picasso и обновления статуса.
```java
@Override
    public void onBindViewHolder(@NonNull TodoViewHolder holder, int position) {
        Todo todo = todos.get(position);
        holder.textViewTitle.setText(todo.getTitle());
        holder.checkBoxCompleted.setChecked(todo.getCompleted());
        String imageUrl = "https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png";
        Picasso.get()
                .load(imageUrl)
                .placeholder(R.drawable.ic_launcher_background)
                .error(R.drawable.ic_launcher_foreground)
                .into(holder.imageView);
```
Поскольку на момент выполнения практической работы запросы для подгрузки изображений из веб-ресурсов работали некорректно (превышение времени ожидания запроса или отказ в доступе), 
было решено вставить URL-адрес изображения с логотипом компании Google для демонстрации работы веб- запроса.

<img width="403" height="889" alt="image" src="https://github.com/user-attachments/assets/6963c8a8-7853-4373-a95b-582cd3feeee6" />

При обновлении статуса CheckBox была добавлена отправка запроса на обновление Todo. Фрагмент кода представлен ниже.

```java
holder.checkBoxCompleted.setOnClickListener(v -> {
            boolean isChecked = holder.checkBoxCompleted.isChecked();
            todo.setCompleted(isChecked);
            apiService.updateTodo(todo.getId(), todo).enqueue(new Callback<Todo>() {
                @Override
                public void onResponse(@NonNull Call<Todo> call, @NonNull Response<Todo> response) {
                    if (response.isSuccessful()) {
                        Log.d("TodoAdapter", "Todo " + todo.getId() + " updated successfully!");
                    } else {
                        Log.e("TodoAdapter", "Update failed with code: " + response.code());
                    }
                }
                @Override
                public void onFailure(@NonNull Call<Todo> call, @NonNull Throwable t) {
                    Log.e("TodoAdapter", "Update failed: " + t.getMessage());
                }
            });
        }
```
<img width="273" height="256" alt="image" src="https://github.com/user-attachments/assets/781c0fdb-c831-47ae-8c3d-78189c8bf9d7" /> <img width="273" height="262" alt="image" src="https://github.com/user-attachments/assets/8079ca41-8728-496b-a2ba-df4002cf1c57" />

<img width="950" height="64" alt="image" src="https://github.com/user-attachments/assets/7c09cd7c-d4a5-42ce-a100-244fb0c0fa5b" />

### **Контрольное задание (PocketDictionary)**

Контрольное задание выполнялось на основном проекте "PocketDictionary". "Заглушки" в data-слое были заменены на реальное взаимодействие с внешними API.

**Реализация получения определений (Retrofit)**
1. Созданы DTO-классы: В пакете data/network были созданы классы `WordDefinitionDto`, `MeaningDto`, `DefinitionDto` для парсинга JSON-ответа от Free Dictionary API.

<img width="446" height="195" alt="image" src="https://github.com/user-attachments/assets/ccd003f1-931b-42a4-9ff7-15d040dcb84e" />

2. Создан интерфейс `DictionaryApi` с GET-запросом для получения определения по слову.

```java
public interface DictionaryApi {
    @GET("api/v2/entries/en/{word}")
    Call<List<WordDefinitionDto>> getDefinition(@Path("word") String word);
}
```
3. Модифицирован класс `NetworkApi`: "Заглушка" была заменена на полноценный Retrofit-клиент. Метод `getDefinitionFromNetwork()` теперь выполняет реальный синхронный сетевой запрос, обрабатывает ответ, проверяет его на ошибки и возвращает `WordDataModel`.
```java
public NetworkApi() {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://api.dictionaryapi.dev/")
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        this.dictionaryApi = retrofit.create(DictionaryApi.class);
    }
    public WordDataModel getDefinitionFromNetwork(String word) {
        Log.i(TAG, "Fetching '" + word + "' from REAL network...");
        try {
            Response<List<WordDefinitionDto>> response = dictionaryApi.getDefinition(word).execute();
            Log.i(TAG, "Response received with code: " + response.code());

            if (response.isSuccessful() && response.body() != null && !response.body().isEmpty()) {
                WordDefinitionDto firstResult = response.body().get(0);

                if (firstResult != null && firstResult.meanings != null && !firstResult.meanings.isEmpty() &&
                        firstResult.meanings.get(0).definitions != null && !firstResult.meanings.get(0).definitions.isEmpty()) {

                    String definitionText = firstResult.meanings.get(0).definitions.get(0).definition;
                    Log.i(TAG, "Definition found: " + definitionText);
//                    int imageId = Math.abs(word.hashCode() % 1000);
//                    String imageUrl = "https://picsum.photos/400/200.jpg?random=" + imageId;
                    int size = 400 + (Math.abs(word.hashCode()) % 10);
                    String imageUrl = "https://place.dog/" + size + "/" + size;

                    return new WordDataModel(word, definitionText, imageUrl, System.currentTimeMillis());
                } else {
                    Log.w(TAG, "Response body is valid, but definitions list is empty.");
                }
            } else {
                Log.e(TAG, "Response was not successful or body is empty. Code: " + response.code());
            }
        } catch (Exception e) {
            Log.e(TAG, "Network request failed or JSON parsing error", e);
        }

        return new WordDataModel(word, "Definition not found", null, System.currentTimeMillis());
    }
```
  
4. Интеграция с архитектурой: `WordRepositoryImpl` без изменений продолжает использовать `NetworkApi`. `MainViewModel` через `ExecutorService` вызывает `UseCase`, который обращается к репозиторию в фоновом потоке, что предотвращает блокировку UI.

**Реализация отображения изображений (Picasso)**

Первоначально, для выполнения задания по отображению релевантных изображений была реализована загрузка картинок с сервиса `placehold.co`. 
При реализации добавлено изображение-заглушка, которая в случае ошибки запросов выводится в окно `ImageView`.
```java
Picasso.get()
            .load(imageUrl)
            .placeholder(R.drawable.ic_launcher_background)
            .error(R.drawable.ic_error)
```
При любом запросе на ресурс `placehold.co` выводилась данная ошибка. В связи с этим было решено воспользоваться ресурсом `place.dog`.
Соотвественно, при вводе слова отправляется два запроса - на определение слова и на выгрузку картинки.

1. Обновлены все модели (WordDefinition, WordDataModel, WordEntity) для хранения поля imageUrl.
2. Обновлен NetworkApi: После получения определения слова, метод getDefinitionFromNetwork() генерирует URL для получения релевантного изображения (например, https://source.unsplash.com/400x200/?{слово}).
3. Обновлен MainActivity: В Observer-е для wordDefinition была добавлена логика Picasso, которая берет imageUrl из полученной модели и загружает его в ImageView. Реализована обработка ошибок загрузки.
4. Обновлен FavoritesAdapter: В onBindViewHolder была добавлена аналогичная логика Picasso для отображения сохраненных изображений в списке избранного.

