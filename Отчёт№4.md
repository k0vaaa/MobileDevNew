# Отчёт по практической работе №4
## Отображение списков в Android

### Цель работы

Целью данной практической работы являлось изучение и практическое освоение основных компонентов Android SDK для отображения списков данных. Основные задачи включали:

-   **Изучение `ScrollView`:** Понимание его назначения и ограничений при работе с большими наборами данных.
-   **Изучение `ListView`:** Освоение базового механизма работы с адаптерами (`ArrayAdapter`) и кастомизации отображения элементов.
-   **Глубокое изучение `RecyclerView`:** Практическая реализация современного и эффективного подхода к отображению списков с использованием паттернов `Adapter`, `ViewHolder` и `LayoutManager`.
-   **Интеграция `RecyclerView` с архитектурой MVVM:** Связывание `RecyclerView` с `ViewModel` и `LiveData` для автоматического обновления списка при изменении данных.
-   **Выполнение контрольного задания:** Реализация экрана "Избранное" в основном проекте "PocketDictionary" с использованием `RecyclerView` и набора тестовых данных ("заглушки").

### Практическая работа

Для последовательного освоения компонентов были созданы три отдельных модуля.

#### ScrollViewApp

Был создан модуль, отображающий геометрическую прогрессию со знаменателем 2 до 100 элемента, демонстрирующий работу `ScrollView`. В `MainActivity` программно, с помощью `LayoutInflater`, было создано 100 `TextView`, которые были добавлены в `LinearLayout` внутри `ScrollView`.

Ниже представлен фрагмент `MainActivity` с реализацией функционала модуля.

```java
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        LinearLayout linearLayout = findViewById(R.id.linearLayoutContainer);

        LayoutInflater inflater = getLayoutInflater();

        for (int i = 0; i < 100; i++) {
            View item = inflater.inflate(R.layout.item, linearLayout, false);

            TextView textView = item.findViewById(R.id.textView);

            long value = (long) Math.pow(2, i);

            textView.setText((i + 1) + ". " + value);

            linearLayout.addView(item);
        }
    }
```

<img width="300" height="650" alt="ScrollViewApp" src="https://github.com/user-attachments/assets/4e28812d-0e98-4ebe-8359-9cb75b3d780e" />

#### ListViewApp

Был создан модуль `ListView`. Был создан список из 30 книг и отображен с помощью стандартного `ArrayAdapter` и макета `simple_list_item_1`.
Ниже представлен фрагмент `MainActivity` с реализацией функционала модуля.
```java
@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ListView listView = findViewById(R.id.listView);
        List<String> bookList = generateBookList();
        ArrayAdapter<String> adapter = new ArrayAdapter<>(
                this,
                android.R.layout.simple_list_item_1,
                bookList
        );

        listView.setAdapter(adapter);
    }
    private List<String> generateBookList() {
        List<String> list = new ArrayList<>();
        list.add("Фрэнк Герберт - Дюна");
        list.add("Айзек Азимов - Основание");
        list.add("Джордж Оруэлл - 1984");
        list.add("Артур Кларк - Космическая одиссея 2001");
        list.add("Уильям Гибсон - Нейромант");
```

<img width="300" height="650" alt="ListViewApp" src="https://github.com/user-attachments/assets/d8307035-e229-4c5b-a713-75ba0152e55b" />

#### RecyclerViewApp

Для изучения `RecyclerView` был создан модуль, отображающий список исторических событий с изображениями. Были реализованы все ключевые компоненты:
-   **Модель данных `Event`**.
-   **Макет для одного элемента списка `item_event.xml`**.
-   **Класс `EventAdapter`**, наследуемый от `RecyclerView.Adapter`.
-   **Вложенный класс `EventViewHolder`** для хранения ссылок на `View` элемента и оптимизации производительности.
-   **`MainActivity`**, где был настроен `RecyclerView` с `LinearLayoutManager` и созданному `Adapter`.

Ниже представлен фрагмент `MainActivity` с реализацией функционала модуля.
```java
private RecyclerView recyclerView;
    private EventAdapter adapter;
    private List<Event> eventList;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        recyclerView = findViewById(R.id.recyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        generateEventList();
        adapter = new EventAdapter(eventList);
        recyclerView.setAdapter(adapter);
    }
    private void generateEventList() {
        eventList = new ArrayList<>();
        eventList.add(new Event("Крещение Руси 988 г.", "Процесс принятия христианства киевским князем Владимиром и его народом.", R.drawable.pic1));
        eventList.add(new Event("Отмена крепостного права 1861 г.", "Реформа, упразднившая крепостное право в России.", R.drawable.pic2));
        eventList.add(new Event("Бородинское сражение 1812 г.", "Крупнейшее сражение Отечественной войны 1812 года между русской и французской армиями.", R.drawable.pic3));
```

<img width="300" height="650" alt="RecyclerViewApp" src="https://github.com/user-attachments/assets/f977b149-a11e-496f-ae8f-1a47b9ef535f" />


### Контрольное задание

Контрольное задание было выполнено в основном проекте "PocketDictionary". Была реализована функциональность экрана "Избранное" в соответствии с требованиями.

1.  **Создан экран `FavoritesActivity`** с макетом, содержащим `RecyclerView`.
2.  **Создан макет `item_favorite.xml`** для отображения одного сохраненного слова и кнопки для его удаления.

<img width="400" height="400" alt="image" src="https://github.com/user-attachments/assets/b2250db1-e1b7-4be7-be5b-6363db04469f" />

3.  **Реализован `FavoritesAdapter`** с вложенным `FavoriteViewHolder` для эффективного отображения списка избранных слов.
4.  **Расширен `Domain`-слой:** В интерфейс `WordRepository` были добавлены методы `getFavorites()` и `removeFavorite()`. Были созданы соответствующие `UseCases` (`GetFavoritesUseCase`, `RemoveFavoriteUseCase`).

<img width="450" height="300" alt="image" src="https://github.com/user-attachments/assets/cdaf191c-0688-4405-aeba-53ae03a530d5" />

5.  **Реализована "заглушка" в `Data`-слое:** В соответствии с заданием, класс `WordRepositoryImpl` был модифицирован. Он больше не обращается к `Room` или `NetworkApi`, а содержит статический `ArrayList` с набором тестовых данных. Методы `getFavorites()`, `saveWordToFavorites()` и `removeFavorite()` теперь работают с этим списком в памяти.

Ниже представлен фрагмент `WordRepositoryImpl` с реализацией "заглушки".

```java
    private static final ArrayList<WordDefinition> STUB_DATA = new ArrayList<>();
    static {
        STUB_DATA.add(new WordDefinition("Android", "An open-source operating system used for smartphones and tablet computers."));
        STUB_DATA.add(new WordDefinition("Java", "A high-level, class-based, object-oriented programming language."));
        STUB_DATA.add(new WordDefinition("Kotlin", "A cross-platform, statically typed, general-purpose programming language with type inference."));
    }
    @Override
    public WordDefinition getDefinition(String word) {
        return new WordDefinition(word, "This is a STUB definition.");
    }
    @Override
    public boolean saveWordToFavorites(WordDefinition word) {
        if (word != null && !STUB_DATA.contains(word)) {
            STUB_DATA.add(word);
        }
        return true;
    }
    @Override
    public List<WordDefinition> getFavorites() {
        System.out.println("Returning STUB data for RecyclerView");
        return STUB_DATA;
    }
    @Override
    public void removeFavorite(WordDefinition word) {
        STUB_DATA.remove(word);
    }
```

6.  **Создан `FavoritesViewModel` и `FavoritesViewModelFactory`:** По паттерну MVVM был создан `ViewModel` для экрана "Избранное", который через `UseCases` получает список-заглушку из репозитория и предоставляет его через `LiveData`.
7.  **Настроена `FavoritesActivity`:** `Activity` получает `ViewModel`, настраивает `RecyclerView` и подписывается на `LiveData`. При получении данных, они передаются в `Adapter`, который обновляет список на экране. Также была реализована логика удаления элемента из списка по нажатию на кнопку.

Ниже представлен фрагмент `FavoritesActivity` с реализацией функционала.

```java
private FavoritesViewModel viewModel;
    private FavoritesAdapter adapter;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_favorites);
        viewModel = new ViewModelProvider(this, new FavoritesViewModelFactory())
                .get(FavoritesViewModel.class);
        RecyclerView recyclerView = findViewById(R.id.favoritesRecyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        adapter = new FavoritesAdapter();
        recyclerView.setAdapter(adapter);
        adapter.setOnDeleteClickListener(word -> {
            viewModel.deleteWord(word);
        });
        viewModel.favoritesList.observe(this, favorites -> {
            adapter.setFavorites(favorites);
        });
        viewModel.loadFavorites();
    }
    @Override
    protected void onResume() {
        super.onResume();
        viewModel.loadFavorites();
    }
```
При нажатии кнопки "Удаления" список избранного обновляется:

<img width="300" height="650" alt="9" src="https://github.com/user-attachments/assets/b738d207-8733-4317-8444-7c1643ee1d8a" /> <img width="300" height="650" alt="10" src="https://github.com/user-attachments/assets/e2f0062b-9089-4e17-a827-bc09bcffcd5c" />

